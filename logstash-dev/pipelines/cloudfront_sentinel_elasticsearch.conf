# input {
#   beats {
#     host => "${LOGSTASH_BEATS_HOST}"
#     port => "${LOGSTASH_BEATS_PORT}"
#   }
# }
input {
  s3 {
    bucket => "${AWS_CLOUDFRONT_BUCKET}"
    region => "${AWS_CLOUDFRONT_REGION}"
    additional_settings => {
      force_path_style => true
      follow_redirects => false
    }
    type => "cloudfront"
    # delete => true
  }
}

filter {

  clone {
    clones => ['clone_for_opensearch']
  }

  if [type] == 'clone_for_opensearch' {

    if ( ("#Version: 1.0" in [message]) or ("#Fields: date" in [message]) ) {
      drop {}
    }

    # Mutate the S3 log fields
    mutate {
      rename => {
        "path" => "s3_log_file"
      }
      remove_field => "host"
    }

    # Grok the CloudFront log format, which is:
    # Fields: date time x-edge-location sc-bytes c-ip cs-method cs(Host) cs-uri-stem sc-status cs(Referer) cs(User-Agent) cs-uri-query cs(Cookie) x-edge-result-type x-edge-request-id x-host-header cs-protocol cs-bytes time-taken x-forwarded-for ssl-protocol ssl-cipher x-edge-response-result-type cs-protocol-version fle-status fle-encrypted-fields c-port time-to-first-byte x-edge-detailed-result-type sc-content-type sc-content-len sc-range-start sc-range-end"
    # https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html#LogFileFormat
    grok {
      match => { "message" => "%{DATE_EU:date}\t%{TIME:time}\t%{DATA:x_edge_location}\t%{NONNEGINT:sc_bytes}\t%{IPORHOST:c_ip}\t%{WORD:cs_method}\t%{HOSTNAME:cs_host}\t%{NOTSPACE:cs_uri_stem}\t%{NONNEGINT:sc_status}\t%{DATA:cs_referrer}\t%{DATA:cs_user_agent}\t%{DATA:cs_uri_query}\t%{DATA:cs_cookie}\t%{WORD:x_edge_result_type}\t%{DATA:x_edge_request_id}\t%{HOSTNAME:x_host_header}\t%{URIPROTO:cs_protocol}\t%{NONNEGINT:cs_bytes}\t%{BASE10NUM:time_taken}\t%{DATA:x_forwarded_for}\t%{DATA:ssl_protocol}\t%{DATA:ssl_cipher}\t%{DATA:x_edge_response_result_type}\t%{DATA:cs_protocol_version}\t%{DATA:fle_status}\t%{DATA:fle_encrypted_fields}\t%{NONNEGINT:c-port}\t%{BASE10NUM:time_to_first_byte}\t%{DATA:x_edge_detailed_result_type}\t%{DATA:sc_content_type}\t%{NONNEGINT:sc_content_len}\t%{DATA:sc_range_start}\t%{GREEDYDATA:sc_range_end}" }
    }

    # Remove the original CloudFront fields - field names and tab separated message.
    mutate {
      remove_field => ["cloudfront_fields", "message"]
    }

  }

}


output {

  # Standard out for debugging in CloudWatch (exclude version and header fields)
  if ( ("#Version: 1.0" not in [message]) and ("#Fields: date" not in [message]) ) {
    stdout {}
  }

  if [type] == 'clone_for_opensearch' {
    # Opensearch output
    opensearch {
      ssl => true
      ssl_certificate_verification => true
      manage_template => false
      ecs_compatibility => disabled
      user => "${ODFE_ELASTICSEARCH_USERNAME}"
      password => "${ODFE_ELASTICSEARCH_PASSWORD}"
      hosts => "${ODFE_ELASTICSEARCH_URL}"
      index => "${AWS_CLOUDFRONT_ELASTICSEARCH_INDEX}"
    }
  }
  else {
    # Sentinel Output
    microsoft-logstash-output-azure-loganalytics {
      workspace_id => "${SENTINEL_WORKSPACE_ID}"
      workspace_key => "${SENTINEL_WORKSPACE_KEY}"
      custom_log_table_name => "${SENTINEL_WORKSPACE_TABLENAME_CLOUDFRONT}"
    }
  }

  sqs {
    queue => "${SQS_OUTPUT_QUEUE}"
    region => "${region}"
  }

}
